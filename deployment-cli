#!/usr/bin/env python3
import argparse
import json
import os
import requests
import subprocess
class ParsedArgs:
    def __init__(self, action, resource, environment, deployment_id, authorization_header, verbose, url, create_payload):
        self.action = action
        self.resource = resource
        self.environment = environment
        self.deployment_id = deployment_id
        self.authorization_header = authorization_header
        self.verbose = verbose
        self.url = url
        self.create_payload = create_payload
        
class GitHubDeploymentManagerParser:
    def __init__(self):
        self.parser = argparse.ArgumentParser(description="GitHub Deployment Manager Command Line Parser")
        self._add_arguments()

    def _add_arguments(self):
        # Add action (get, delete, create)
        self.parser.add_argument('action', choices=['get', 'delete', 'create'], help='Action to perform')

        # Add environment and deployment id
        self.parser.add_argument('environment', nargs='?', default=None, help='Environment name')
        self.parser.add_argument('deployment_id', nargs='?', default=None, help='Deployment ID')

        # Add global options
        self.parser.add_argument('--authorization_header', default=os.getenv('GITHUB_AUTH_HEADER', 'default_value_from_env'), help='Authorization header value')
        self.parser.add_argument('--verbose', action='store_true', help='Enable verbose mode')

        # Add GitHub API URL with a default value
        self.parser.add_argument('--api_url', default='https://api.github.com', help='GitHub API URL')

        # Add options for repo owner and repo name
        self.parser.add_argument('--repo-owner', help='Repository owner')
        self.parser.add_argument('--repo-name', help='Repository name')

        # Create Deployment payload
        self.parser.add_argument('--payload', help='json data to create a new deployment')

    def get_repo(self):
        # Check if both --repo-owner and --repo-name are provided
        if self.repo_owner and self.repo_name:
            return self.repo_owner, self.repo_name
        elif self.repo_owner or self.repo_name:
            # If only one of them is provided, fail
            raise ValueError("Both --repo-owner and --repo-name must be provided or neither.")

        # Attempt to get the default owner and repo from the git remote URL
        try:
            remote_url = subprocess.check_output(["git", "config", "--get", "remote.origin.url"]).decode("utf-8").strip()
            if remote_url.endswith(".git"):
                parts = remote_url.split("/")
                owner = parts[-2]
                repo = parts[-1].rstrip(".git")
                return owner, repo
            else:
                raise ValueError("Remote URL does not appear to be from GitHub.")
        except Exception as e:
            raise ValueError(f"Error while getting default owner and repo: {e}")


    def parse_command_line(self):
        args = self.parser.parse_args()

        # Store repo-owner and repo-name from command line options
        self.repo_owner = args.repo_owner
        self.repo_name = args.repo_name

        resource = "none"
        # Determine the resource based on provided options
        if args.environment and args.deployment_id:
            resource = "deployment"
        elif args.environment:
            resource = "environment"

        # Call getRepo method only if both options are not present
        owner, repo_name = self.get_repo() if not (self.repo_owner and self.repo_name) else (self.repo_owner, self.repo_name)

        # Build the URL using the provided or default values
        url = f"{args.api_url}/repos/{owner}/{repo_name}"
        # Return the parsed arguments
        return ParsedArgs(
            action=args.action,
            resource=resource,
            environment=args.environment,
            deployment_id=args.deployment_id,
            authorization_header=args.authorization_header,
            verbose=args.verbose,
            url=url,
            create_payload=args.payload
        )
    
class GitHubDeployment:
    def __init__(self, api_base_url, token=None):
        self.token = token
        self.api_base_url = api_base_url
        
    def handle_api_errors(self, response, action):
        if response.status_code == 401:
            print(f"Error: Unauthorized. Please check your access token.")
        elif response.status_code == 403:
            print(f"Error: Forbidden. The provided token may not have sufficient permissions for {action}.")
        else:
            print(f"Error: {action} failed with status code {response.status_code}.")
            print("Response:", response.text)

    def delete_environment(self, environment_name):
        environment_url = f"{self.api_base_url}/environments/{environment_name}"
        headers = {"Authorization": self.token}
        response = requests.delete(environment_url, headers=headers)
        if response.status_code == 204:
            print(f"Deleted environment {environment_name} successfully.")
        elif response.status_code == 404:
            print(f"Environment {environment_name} not found. Nothing to delete.")
        else:
            self.handle_api_errors(response, "Delete environment")
            print("Response:", response.text)

    def delete_deployment(self, deployment_id):
        deployment_url = f"{self.api_base_url}/deployments/{deployment_id}"
        headers = {"Authorization": self.token}
        response = requests.delete(deployment_url, headers=headers)
        if response.status_code == 204:
            print(f"Deleted deployment {deployment_id} successfully.")
        elif response.status_code == 404:
            print(f"Deployment {deployment_id} not found. Nothing to delete.")
        else:
            self.handle_api_errors(response, "Delete deployment")
            print("Response:", response.text)

    def list_deployments(self, environment_name):
        deployments_url = f"{self.api_base_url}/deployments"
        headers = {"Authorization": self.token}
        params = {"environment": environment_name} if environment_name else {}
        response = requests.get(deployments_url, headers=headers, params=params)
        if response.status_code == 200:
            deployments_json = response.json()
            deployment_ids = [deployment["id"] for deployment in deployments_json]
            print("Deployment IDs:", deployment_ids)
            return deployment_ids
        elif response.status_code == 404:
            print(f"No deployments found for environment {environment_name}.")
            return []
        else:
            self.handle_api_errors(response, "List deployments")
            print("Response:", response.text)
            return None

    def list_all_environments(self):
        environments_url = f"{self.api_base_url}/environments"
        headers = {"Authorization": self.token}
        response = requests.get(environments_url, headers=headers)

        try:
            response.raise_for_status()
            environments_json = response.json()

            if isinstance(environments_json, list):
                self.print_environments(environments_json)
            elif isinstance(environments_json, dict) and "environments" in environments_json:
                self.print_environments(environments_json["environments"])
            else:
                print("Error: Unexpected response format.")
                print("Response:", response.text)
        except requests.exceptions.HTTPError as http_err:
            if response.status_code == 404:
                print("No environments found.")
            else:
                print(f"HTTP error occurred: {http_err}")
                print("Response:", response.text)
        except json.JSONDecodeError as json_err:
            print(f"JSON decoding error occurred: {json_err}")
            print("Response:", response.text)
        except Exception as err:
            print(f"An error occurred: {err}")

    def print_environments(self, environments):
        if not environments:
            print("No environments found.")
        else:
            environment_names = [env["name"] for env in environments]
            print("Available Environment Names:", environment_names)

    def view_deployment(self, deployment_id):
        deployment_url = f"{self.api_base_url}/deployments/{deployment_id}"
        headers = {"Authorization": self.token}
        response = requests.get(deployment_url, headers=headers)
        if response.status_code == 200:
            deployment_info = response.json()
            print("Deployment Information:", json.dumps(deployment_info, indent=2))
        elif response.status_code == 404:
            print(f"Deployment {deployment_id} not found.")
        else:
            self.handle_api_errors(response, "View deployment")
            print("Response:", response.text)

    def create_deployment(self, deployment_payload_json):
        headers = {"Authorization": self.token}

        try:
            deployment_payload = json.loads(deployment_payload_json)
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON: {e}")
            return

        deployment_url = f"{self.api_base_url}/deployments"
        response = requests.post(deployment_url, headers=headers, data=json.dumps(deployment_payload))
        if response.status_code == 201:
            deployment_info = response.json()
            deployment_id = deployment_info.get("id")
            print(f"Created a new deployment (ID: {deployment_id}) successfully.")
        else:
            self.handle_api_errors(response, "Create deployment")
            print("Response:", response.text)

if __name__ == "__main__":
    parser = GitHubDeploymentManagerParser()

    # Get the parsed arguments
    args = parser.parse_command_line()

    # Create an instance of GitHubDeployment with the parsed arguments
    util = GitHubDeployment(api_base_url=args.url, token=args.authorization_header)

    # Call the appropriate method based on the action
    if args.action == "get":
        if args.resource == "none":
          util.list_all_environments()
        elif args.resource == "environment":
          util.list_deployments(args.environment)
        elif args.resource == "deployment":
          util.view_deployment(args.deployment_id)
        pass
    elif args.action == "delete":
        if args.resource == "deployment":
            util.delete_deployment(args.deployment_id)
        elif args.resource == "environment":
            util.delete_environment(args.environment)
    elif args.action == "create":
        util.create_deployment(args.create_payload)
        pass
    else:
        print("Invalid action.")